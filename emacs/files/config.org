#+TITLE:Arnaud Spiwack's emacs configuration
#+PROPERTIES: header-args:emacs-lisp  :tangle yes
#+startup: overview

I wrote my configuration file in [[http://orgmode.org/worg/org-contrib/babel/][Orgmode/Babel]], a literate programming
format. It allows me to structure the file better as it was getting
quite unwieldy, and make the comments more useful. It also makes it
nicer to share.

Orgmode/Babel can serve as a literate programming tool for any
language. It is meant to be edited with Emacs. There is special
support to load a Babel file containing Emacs lisp from an Emacs lisp
file, namely the function ~org-babel-load-file~. It is pretty much
intended to be used to load an Emacs configuration such as this one.

* Header

The semantics of binding in vanilla elisp is so called [[https://en.wikipedia.org/wiki/Late_binding][/dynamic
bindings/]], a bug in the original Lisp become standard (Scheme changed
that). Mostly, it's horrible. The following makes binders /lexical/
(aka /static/) by default.
#+BEGIN_SRC emacs-lisp
  ;;; -*- lexical-binding: t -*-
#+END_SRC

* Use this file

In my ~.dotfiles~, I call this file from Nix. A more standard way of setting up a
Doom Emacs config is to have this file, as well as ~init.el~ and ~packages.el~ be in
the ~.config/doom.d/~ directory. Don't forget to activate the ~literate~ module in
~init.el~ which lets Doom read this Org file and turn it into a ~config.el~ file
that Emacs can read.

* COMMENT Use-package

The [[https://github.com/jwiegley/use-package][~use-package~]] macro helps structure Emacs configurations by
arranging and scoping the configuration by package.


** Bootstrapping use-package

The ~use-package~ macro can install packages from Melpa, but it cannot
install itself. So we need a bit of bootstrapping code to get
ourselves started:
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-minimum-reported-time 0.05)
  (setq use-package-verbose t)
#+END_SRC



* TODO Preliminaries

Move opam stuff (from Melt & Ocaml) to here.

* TODO Stuff I don't want to deal with right now

#+BEGIN_SRC emacs-lisp
  ;; compilation key-bindings
  (global-set-key (kbd "<f10>") 'compile)
  (global-set-key (kbd "<f11>") 'next-error)

  ;; Don't use tabs for indentation
  (setq-default indent-tabs-mode nil)

  ;; Packages to install via Melpa: company-coq
  ;; Stuff to install on the system: hindent (stack), Proof general (sources), ocp-indent (opam), merlin (opam), tuareg-mode (system)
  ;; Note: packages installed via Melpa must be configured using the `after-init-hook`
#+END_SRC

* Emacs settings

** Don't modify ~init.el~

Emacs likes to modify the ~init.el~ to store customisation. It prevents
me from having a fully declarative configuration as either I have to
check the customisation information in my configuration repository, or
I have to not control the ~init.el~ via my declarative configuration
(and have to manually add a line in ~init.el~ to call this here file).

This configuration lets Emacs store customisation information in
~custom.el~ instead. Which is then only controlled by Emacs, and
separate from my configuration.

#+begin_src emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file)
#+end_src

** Backup files to a dedicated directory

Instead of saving the backup files (both autosave files of the form
~#filename#~ and backup saves of the form ~\~filename~) in the same
directory as the files they are backuping, cleanly store them in a
dedicated directory (here ~\~/.emacs.d/backups~).

The code for this comes from [[http://stackoverflow.com/a/18330742][a stack overflow comment]].
#+BEGIN_SRC emacs-lisp
  (defvar --backup-directory (concat user-emacs-directory "backups"))
  (if (not (file-exists-p --backup-directory))
          (make-directory --backup-directory t))
  (setq backup-directory-alist `(("." . ,--backup-directory)))
  ; (setq auto-save-file-name-transforms `(("." ,--backup-directory)))
  (setq make-backup-files t               ; backup of a file the first time it is saved.
        backup-by-copying t               ; don't clobber symlinks
        version-control t                 ; version numbers for backup files
        delete-old-versions t             ; delete excess backup files silently
        delete-by-moving-to-trash t
        kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
        kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
        auto-save-default t               ; auto-save every buffer that visits a file
        auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
        auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
        )
#+END_SRC

** Don't pop up compilation warnings

#+begin_src emacs-lisp
  (setq native-comp-async-report-warnings-errors nil)
#+end_src
** Initial theme
#+begin_src emacs-lisp
(setq doom-theme 'catppuccin)
#+end_src

* General purpose packages

** Appearance

*** Remove default behaviour

#+begin_src emacs-lisp
  ;; deactivate tool bar
  (tool-bar-mode -1)

  ;; deactivate the menu bar
  (menu-bar-mode -1)

  ;; deactivate the scroll bar
  (scroll-bar-mode -1)
#+end_src

*** Diminish

The [[https://github.com/myrjola/diminish.el][~diminish~]] package is used to unclutter the minor-mode line. It can
be used to remove the mention of the minor-mode in the line when we
don't want to be reminded of it. The ~diminish~ functionality is
called via ~use-package~ with the ~:diminish~ keyword.
#+BEGIN_SRC emacs-lisp
  (use-package diminish)
#+END_SRC

*** Fonts
#+begin_src emacs-lisp
  ; Don't set an absolute size for any but the default face, otherwise,
  ; it seems that you can't change the size of the font with `C-x C-+'
  ; and `C-x C--'.
  (set-face-attribute 'default nil :family "DejaVu Sans Mono" :height 98)
  (set-face-attribute 'fixed-pitch nil :family "DejaVu Sans Mono" :inherit 'default :height 0.77)
  (set-face-attribute 'variable-pitch nil :family "Linux Biolinum O" :inherit 'default :height 1.3)
  (defface aspiwack/programming '((t :inherit variable-pitch-face)) "Variable pitch font for programming")
  (set-face-attribute 'aspiwack/programming nil :family "DejaVu Sans" :inherit 'default :height 1.05)
#+end_src

Note for debugging: calling ~C-u C-x =~ gives a lot of information at
point, including the face.

*** Colour themes

I use themes of the Catppuccin theme set. This lets me have some consistent
theming between light and dark theme.

Let me define two functions (~M-x dark-theme~) and (~M-x
light-theme~) to switch between them. Let me also define a more general
function ~switch-theme~ which acts as ~load-theme~ (it loads and activates
a theme), but also deactivates all other custom themes, so that we can
easily change between available themes.
#+BEGIN_SRC emacs-lisp
  (defun dark-theme ()
    (interactive)
    (setq catppuccin-flavor 'mocha)
    (catppuccin-reload)
    )

  (defun light-theme ()
    (interactive)
    (setq catppuccin-flavor 'latte)
    (catppuccin-reload)
    )
#+END_SRC
**** Switch theme based on the desktop theme

This sets the theme to light or dark depending on whether the
desktop's theme is light or dark. It uses dbus to react to changes,
and ~org.freedesktop.portal.Desktop~ as the value to observe (this
should work on most Linux desktop environments). The code is (lightly)
adapted from [[https://www.reddit.com/r/emacs/comments/o49v2w/comment/i5ibcyv/?utm_source=reddit&utm_medium=web2x&context=3][this Reddit answer]].

#+begin_src emacs-lisp
  (use-package dbus)

  (defun aspiwack/set-theme-from-dbus-value (value)
    "Set the appropiate theme according to the color-scheme setting value."
    (message "value is %s" value)
    (if (equal value '1)
        (progn (message "Switch to dark theme")
               (dark-theme))
      (progn (message "Switch to light theme")
             (light-theme))))

  (defun aspiwack/color-scheme-changed (path var value)
    "DBus handler to detect when the color-scheme has changed."
    (when (and (string-equal path "org.freedesktop.appearance")
               (string-equal var "color-scheme"))
      (aspiwack/set-theme-from-dbus-value (car value))
      ))

  ;; Register for future changes
  (dbus-register-signal
     :session "org.freedesktop.portal.Desktop"
     "/org/freedesktop/portal/desktop" "org.freedesktop.portal.Settings"
     "SettingChanged"
     #'aspiwack/color-scheme-changed)

  ;; Request the current color-scheme
  (dbus-call-method-asynchronously
   :session "org.freedesktop.portal.Desktop"
   "/org/freedesktop/portal/desktop" "org.freedesktop.portal.Settings"
   "Read"
   (lambda (value) (aspiwack/set-theme-from-dbus-value (caar value)))
   "org.freedesktop.appearance"
   "color-scheme"
   )
#+end_src
*** Misc

#+begin_src emacs-lisp
  ;; Displays column number in the modeline
  (column-number-mode)
#+end_src

** Emacs behaviour

*** Which-key

[[https://github.com/justbur/emacs-which-key#manual-activation][Which-key]] display key binding completions.

#+begin_src emacs-lisp
  (use-package which-key
      :diminish which-key-mode
      :config
      (which-key-mode)
      :custom
      (which-key-idle-delay 0.3))
#+end_src

** Editing

*** COMMENT Completion

[[https://github.com/minad/corfu][Corfu]] is a lightweight completion-at-point extension for Emacs.

#+begin_src emacs-lisp
  (use-package corfu
    :init
    (global-corfu-mode)
    :config
    (setq corfu-auto t
         corfu-auto-delay 0
         corfu-auto-prefix 2))
#+end_src

[[https://github.com/minad/cape][Cape]] is a complement to Corfu (or really any completion engine) adding
completion functions. It also provides a way to avoid caching LSP
completions since these are regenerated all the time.

#+begin_src emacs-lisp
  (use-package cape
    :init
    (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)
    (add-hook 'completion-at-point-functions #'cape-file)
    (add-hook 'completion-at-point-functions #'cape-emoji)
    (add-hook 'completion-at-point-functions #'cape-tex))
#+end_src

[[https://github.com/rainstormstudio/nerd-icons-completion][Nerd-icons-completion]] adds icons from Nerdfonts to the completion
suggestions

#+begin_src emacs-lisp
  (use-package nerd-icons-completion
    :config
    (nerd-icons-completion-mode))
#+end_src

*** Swiper search

[[https://github.com/abo-abo/swiper][Swiper]] is a tool to improve the search capabilities of Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :bind
    (; Rebinds the search key binding `C-s` to Swiper search function
     ("C-s" . swiper)))
#+END_SRC

*** COMMENT Helm

[[https://emacs-helm.github.io/helm/][Helm]] is a powerful "narrowing" mode. It helps searching and selecting
in files and lists (/e.g./ find-file).
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :config
    (helm-mode t)
    :defer 2 ; still enables helm mode after a short while if no
             ; autoload has been used.
    :bind
    (("M-x" . helm-M-x)
     ("C-x C-f" . helm-find-files)
     ("C-x b" . helm-mini)
     ;; helm-occur is helm's search command. For most uses Swiper
     ;; offers a superior experience (the only point in favour of helm
     ;; is that it makes it possible to search patterns typing words
     ;; in the wrong order
     ;; (e.g. "list type" maches "type 'a list")).
     ;; ("C-s" . helm-occur)
     ; The 3 following commands override unpleasant default from
     ; Helm. Mostly this sets up `tab` to do things like select a
     ; directory in `find-file` buffers, rather than open a
     ; menu. (default was `C-z`, both are switch. I am not sure what the
     ; `C-i` rebinding is for). These are taken from the internet [
     ; http://tuhdo.github.io/helm-intro.html ]
     :map helm-map
     ("<tab>" . helm-execute-persistent-action) ; rebind tab to do persistent action
     ("C-i" . helm-execute-persistent-action) ; make TAB works in terminal
     ("C-z" . helm-select-action) ; list actions using C-z
     )
    :diminish helm-mode)
#+END_SRC

To search files in a project (git, darcs, etc…), I use
[[https://github.com/bbatsov/helm-projectile][helm-projectile]]. In particular for the ~helm-projectile-ag~
command. It also replaces the ido-based completion in projectile with
helm.
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :commands helm-projectile-on
    :bind
    ("C-S-s" . helm-projectile-rg))

  ;; Dynamic dependency of `helm-projectile'. I might as well install it
  ;; automatically instead of doing this on the first call to
  ;; `helm-projectile-rg' on each installation.
  (use-package helm-rg
    :commands helm-rg)
#+END_SRC

*** Counsel

Counsel is very similar to Helm. I usually prefer Helm for the job,
but sometimes Counsel does a better job for me. Notably to replace
~org-goto~ in Org mode.

#+begin_src emacs-lisp
  (use-package counsel)
#+end_src

*** Multiple cursors

The [[https://github.com/magnars/multiple-cursors.el][mutliple cursor mode]] makes it possible to have several cursors in
an emacs buffer, allowing to act simultaneously at several points of
the buffer.

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :bind
    (; change a multi-line region in multiple cursors
     ("C-S-c C-S-c" . mc/edit-lines)
     ; When no region is selected: add a cursor below point. When a
     ; region is selected, add a new cursor selecting next identical
     ; region.
     ("C->" . mc/mark-next-like-this)
     ; Like above but puts cursor above point or at previous identical
     ; region.
     ("C-<" . mc/mark-previous-like-this)
     ; Select all identical to current region
     ("C-c C-<" . mc/mark-all-like-this)))
#+END_SRC

*** Electric pairs

The [[https://www.emacswiki.org/emacs/ElectricPair][electric pair mode]] creates delimiters by pairs (/e.g./ when
writing an opening parenthesis, it will output a matching closing
parenthesis). The choice of delimiters to consider is based on the
syntax of the current major mode.

#+BEGIN_SRC emacs-lisp
  (electric-pair-mode 1)
#+END_SRC

*** Rainbow delimiters

The [[https://www.emacswiki.org/emacs/RainbowDelimiters][rainbow-delimiters mode]] colours nested delimiters in different
colours so that it is easier to spot pairs of matching delimiters.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook
    (prog-mode . rainbow-delimiters-mode))
#+END_SRC

**** TODO Improve colour scheme

*** COMMENT Spell checking
The [[http://www-sop.inria.fr/members/Manuel.Serrano/flyspell/flyspell.html][Flyspell]] mode spell checks text (or just comments for programming
languages with the ~flyspell-prog-mode~)
#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :init
    (custom-set-variables
       ; Selects flyspell's default dictionary
       '(flyspell-default-dictionary "british-ise-w_accents"))
    ;; :bind
    ;; ; Proposes corrections for the last word found by flyspell before
    ;; ; the current cursor position. Cheat-sheet: candidate number to
    ;; ; substitute a proposed correction, `A' to add a the word as a local
    ;; ; word, `r' to manually replace the word.
    ;; ("C-c C-j" . flyspell-check-previous-highlighted-word)
    )
#+END_SRC

[[https://github.com/d12frosted/flyspell-correct][Flyspell-correct]] augments Flyspell with keyboard-friendly commands
(which I bound to "j" in the search map). Vanilly Flyspell is really
better for use with the mouse (which is fine, but I often want to
reach for my keyboard).

Flyspell-correct integrates into Helm nicely (also other command
completion framework if you'd rather use Ivy or something).

#+begin_src emacs-lisp
  (use-package flyspell-correct
    :after flyspell
    :commands (flyspell-correct-previous flyspell-correct-next))

  ;; (use-package flyspell-correct-helm
  ;;   :after flyspell-correct)
#+end_src


*** COMMENT White-space butler

The [[https://github.com/lewang/ws-butler][~ws-butler~ mode]] erases trailing white spaces which would pollute
your diffs in version control systems. But only on those lines you
have actually edited to keep your commits minimal and meaningful even
if you are working with people who, for any reason, leave white spaces
behind.
#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :diminish ws-butler-mode
    :config (ws-butler-global-mode))
#+END_SRC

I run ~ws-butler~ in all my buffers.

*** COMMENT hungry-delete-mode

[[https://github.com/nflath/hungry-delete/][Hungry-delete mode]] deletes consecutive white-spaces as if they were a
single character (See also
http://endlessparentheses.com/hungry-delete-mode.html).

#+BEGIN_SRC emacs-lisp
  ;; (use-package hungry-delete
  ;;   :config
  ;;   (global-hungry-delete-mode)
  ;;   :diminish hungry-delete-mode)
#+END_SRC
*** COMMENT Yasnippet

[[https://github.com/joaotavora/yasnippet][Yasnippet]] inserts templates (with holes which can be navigated with
tabs). I'm experimenting with it, I can't recommend it just yet.
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config
    (yas-global-mode)
    :diminish yas-minor-mode
    :defer 2)
#+END_SRC

*** Ace windows

[[https://github.com/abo-abo/ace-window][Ace-window]] provides a faster way to navigate between windows. I rebind
it on ~C-x o~ (usually ~other-window~) since it behaves like
~other-window~ when there are only two windows. When they are more
~ace-window~ gives a number to each window and typing that number
switch to said window.
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind ("C-x o" . ace-window)
    :config
    (ace-window-display-mode 1))
#+END_SRC

*** Avy

[[https://github.com/abo-abo/avy][Avy]] provides fast ways to jump to a word on screen (it can jump
between windows as well). I haven't set bindings because I use Avy via
[[https://github.com/jyp/boon][Boon]].
#+BEGIN_SRC emacs-lisp
  (use-package avy)
#+END_SRC

*** Boon

[[https://github.com/jyp/boon][Boon]] is a modal binding for Emacs. An alternative is [[https://bitbucket.org/lyro/evil/wiki/Home][Evil]] (together
with the crowd-sourced [[http://spacemacs.org/][Spacemacs]] bindings) which provides more
vi-like bindings. But overall, I don't really likes these
bindings. Boon is better-suited to my needs.

I'm defining a lot of custom keys here. I think that most of them
would be better suited in the ~use-package~ of their respective
package. However, I found that it doesn't always work to do so. So I'm
being conservative and define most boon-type bindings here.

#+BEGIN_SRC emacs-lisp
  (use-package boon
    :config
    (require 'boon-qwerty)
    (boon-mode)
    ;; I'm pretty sure this is the wrong mode map for search queries but
    ;; it does work just fine This whole section should be moved to a
    ;; `:bind' (with `:map' sections). But I'm lazy right now.
    (define-key boon-moves-map "e " 'swiper)
    (define-key boon-moves-map "eg" 'consult-ripgrep)
    ;; (define-key boon-moves-map "ey" 'helm-show-kill-ring)
    (define-key boon-x-map "f" 'find-file)
    (define-key boon-moves-map "wj" 'flyspell-correct-previous)
    (define-key boon-moves-map "ej" 'flyspell-correct-next)
    (define-key boon-goto-map "d" 'dired-jump)
    ; return to command mode on `keyboard-quit`
    (defadvice keyboard-quit (before aspiwack/set-cmd-when-quit activate)
      "On `C-g' (`keyboard-quit'), return to Boon command mode."
      (boon-set-command-state))
    (define-prefix-command 'aspiwack/boon-custom-map nil "custom")
    (define-key boon-command-map "m" 'aspiwack/boon-custom-map)

    ; Since the powerline/doom-modeline indicates boom's mode, we can safely remove
    ; the normal boon indication from the mode line.
    :diminish boon-local-mode
      )
#+END_SRC

** Programming

*** COMMENT Flycheck

[[http://www.flycheck.org/][Flycheck]] continuously compiles a project and reports compilation and
typing errors inline.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck)
#+END_SRC

*** Aidermacs
[[https://github.com/MatthewZMD/aidermacs][Aidermacs]] is an interface to LLM models (via the command-line tool
[[https://aider.chat/][Aider]], reading Aider's documentation is probably necessary to get
started)
#+begin_src emacs-lisp
  (use-package aidermacs
    :config
    (define-key aspiwack/boon-custom-map "o" 'aidermacs-transient-menu)
    :custom
    ; See the Configuration section below
    (aidermacs-use-architect-mode t)
    (aidermacs-default-model "sonnet"))
#+end_src
** COMMENT Git

[[http://magit.vc/][Magit]] is downright the best tool I've ever used to control git
repositories. And I've used quite a few.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    ; magit is only loaded when `magit-status' is called
    :commands magit-status
    :custom
    (magit-wip-merge-branch t "Merge real commits in wip branch")
    (magit-diff-refine-hunk 'all "Display magit's diffs with word-granularity")
    (magit-display-buffer-function 'magit-display-buffer-fullcolumn-most-v1 "Avoid splitting buffers vertically")
    :init
    (magit-wip-mode)
    ;; I don't really know why I can't use `:diminish' for
    ;; `magit-wip-mode', but it doesn't work, so let me add it here.
    (diminish 'magit-wip-mode))
#+END_SRC

Note: I do like to ~pull --rebase~ often. Magit lets me set the
behaviour of pulls on individual branches: in the ~pull~ menu, press
~r~ to toggle a default ~rebase~ or ~merge~ behaviour for the
branch. It turns out to simply be an interface to Git's
configuration. It can be toggled in the command line by ~git config
--local branch.<branch name>.rebase true~.

I can set rebase as the default globally with ~git config --global
pull.rebase true~.

*** Pull requests

[[https://magit.vc/manual/forge/][Forge]] is an extension of Magit to manage Issues/PRs and more from
Emacs. It does require some out-of-Emacs setup which cannot be
automated. This is described [[https://magit.vc/manual/forge/Getting-Started.html#Getting-Started][in the relevant part of the Forge manual]].

#+begin_src emacs-lisp
  (use-package forge
    :after magit)
#+end_src

Some documentation that I assembled before actually setting up
Forge. Some of the documentation is about other Emacs packages. I've
tried one, I think it was ~magit-gh-pulls~. Because it was attempting
to read out information from Github as soon as I opened my Magit
status, it was slowing down my workflow significantly, and I
uninstalled it. Forge lets me choose when to connect to Github to
refresh issues and PR. And one of the thing which convinced me to set
it up was that it lets me create a Github fork right from my
Emacs. Since it's a tad tedious a process, usually, it's a rather
pleasant feature.
- (more recent) https://magit.vc/manual/forge/
- https://github.com/sigma/magit-gh-pulls
- http://endlessparentheses.com/merging-github-pull-requests-from-emacs.html
- http://endlessparentheses.com/create-github-prs-from-emacs-with-magit.html

** Darcs

For darcs repository, I use [[http://hub.darcs.net/simon/darcsum][darcsum]]. It's much less featureful than
Magit. But it's serviceable.
#+BEGIN_SRC emacs-lisp
  (use-package darcsum
    ; darcsum is only loaded when `darcsum-whatsnew' is called
    :commands darcsum-whatsnew)
#+END_SRC

The ~projective-vc~ function from the [[http://batsov.com/projectile/][Projectile]] project management
package abstracts over version control systems (it will open magit for
git, for instance). However, it doesn't know of darcsum. So I define
my own dispatch (using Projectile to discover what kind of source
control we're currently under).
#+BEGIN_SRC emacs-lisp
  (defun aspiwack/vc (&optional project-root)
    (interactive)
    ; setup variables, logic taken from
    ; https://github.com/bbatsov/projectile/blob/44f75e3ceceeebac7111954e6f33cda50d4793d5/projectile.el#L2694-L2695
    (or project-root (setq project-root (projectile-project-root)))
    (let ((vcs (projectile-project-vcs project-root)))
      ; dispatching on vcs kind
      (cl-case vcs
        (darcs (darcsum-whatsnew project-root))
        (otherwise (projectile-vc project-root)))
      )
    )
#+END_SRC

** Project management

[[http://batsov.com/projectile/][Projectile]] is a project management library: it has functionalities to,
among other things list or search the files in a project. Projects are
typically the files checked in a version control system.

A useful projectile command is ~projectile-find-other-file~ (bound to
~<projectile prefix> a~) which switches between lists with the same
basename but different extensions (it uses a list of matching
extension: for instance, it can switch between ~.c~ and ~.h~ files in
C projects).
#+BEGIN_SRC emacs-lisp
  ;; A function to figure out names for a git repository based on the
  ;; name of the remote repository and current branch. Useful because I
  ;; use `git worktree' a lot.
  (defun aspiwack/git-repo-name (project-root)
    (require 's) ; string processing library
    (let (remotes (shell-command-to-string "git remote -v"))
      (if (string= remotes "")
          ; in case there is no remote, use the directory's basename
          (projectile-default-project-name project-root)
        ; TODO: can we make sure this is run from the project root?
        (let ((repo-name
               (s-trim (shell-command-to-string "git remote -v | head -n1 | cut -f2 | cut -d ' ' -f1 | xargs basename | sed -e 's/.git$//'")))
              (branch-name
               (s-trim (shell-command-to-string "git branch --no-color | grep '^*' | cut -c3-"))))
          (format "%s" repo-name)))
      ))

  (use-package projectile
    :commands ; entry points for projectile
    (projectile-project-vcs
     projectile-project-root
     projectile-vc
     projectile-default-project-name)
    :bind
    ; Use `C-x g` to open the VCS (Magit, darcsum) dashboard
    ("C-x g" . aspiwack/vc)
    :bind-keymap
    ; sets the prefix for projectile command to be `C-x p' (default
    ; `C-c p').
    ("C-x p" . projectile-command-map)
    :config
    ; starts projectile
    (projectile-global-mode)
    ; Set the projectile keymap
    ; The following should be `:bind-keymap'. But for some reason
    ; `:bind-keymap' doesn't seem happy with the `:map' modifier. See
    ; https://github.com/jwiegley/use-package/issues/736
    (define-key aspiwack/boon-custom-map "p" 'projectile-command-map)
    ; customises the mode line display
    (setq projectile-mode-line
         '(:eval
           (if
               (file-remote-p default-directory)
               " [<remote>]"
             (format " [%s]"
                     (projectile-project-name)))))
    ; discover better project names
    (setq projectile-project-name-function
          (lambda (project-root)
            (let ((vcs (projectile-project-vcs project-root)))
              (cl-case vcs
                ; In git repositories, I use worktrees and it makes the
                ; name of the root directory (default project name) very
                ; uninformative. Instead I use a project name based on
                ; repository name and branch name.
                (git (aspiwack/git-repo-name project-root))
                (otherwise (projectile-default-project-name project-root))))))
    ; replaces ido-based completion for projectile command with
    :defer 0 ; loads immediately, overrides the autoloads.
    )
#+END_SRC

* Languages

** Publishing formats

Here is some configuration shared by all text editing modes which
derive from ~text-mode~ (in Emacs terminology, ~text-mode~ is a base
mode, and modes like ~markdown-mode~ derive from ~text-mode~).
#+BEGIN_SRC emacs-lisp
  (defun aspiwack/auto-fill-everywhere ()
    ; This is only necessary for org-mode, in other text modes,
    ; `comment-auto-fill-only-comments' doesn't actually have any
    ; effect. Maybe there is a better way to do auto-filling in Org
    ; which we could use instead.
    ; It doesn't work anymore though. I thought it worked once. Maybe
    ; that's the problem with variables being global state. And as soon
    ; as there is a code snippet then `comment-auto-fill-only-comments'
    ; gets reset to `t'. I don't know.
    (setq comment-auto-fill-only-comments nil)
    (auto-fill-mode 1))

  (use-package text-mode
    :hook
    ; Automatically start a new line when the current line is full
    (text-mode . aspiwack/auto-fill-everywhere)
    ; Use flyspell for online spell-checking
    (text-mode . turn-on-flyspell)
    )
#+END_SRC

*** Org mode

Not only a publishing format, but also a powerful editing mode (with
which I wrote this file), a literate programming tool, an agenda, a
todo list manager, a spreadsheet program and more… [[http://orgmode.org/][Org mode]] is the
most iconic Emacs mode.

This configuration uses [[https://orgmode.org/manual/Noweb-Reference-Syntax.html#Noweb-Reference-Syntax][Noweb syntax]] because ~:config~ [[https://github.com/jwiegley/use-package/issues/882][doesn't seem to
work with functions defined below]].

#+BEGIN_SRC emacs-lisp :noweb yes
  <<org-helpers>>

  (defun aspiwack/org-setup-babel ()
    ; Turns on syntax highlighting in code blocks
    (setq org-src-fontify-natively t))

  (defun aspiwack/org-setup-capture ()
    ; Sets up capture in org mode see http://orgmode.org/org.html#Capture
    ; templates
    (setq org-capture-templates
          '(("w" "Work todo" entry (file+headline "~/Dropbox/Org/log.org" "Work")
             "* TODO %?\n  %i\n  %a")
            ("t" "Personal todo" entry (file+headline "~/Dropbox/Org/log.org" "Perso")
             "* TODO %?\n  %i\n  %a")))
    ; key binding
    (define-key global-map "\C-cc" 'org-capture))

  (use-package org
    :defer t ; defer doesn't work on org, apparently and the
             ; configuration is rather slow. Need to figure something
             ; out.
    :hook
    ((org-mode . variable-pitch-mode)
     (org-mode . org-indent-mode)
     (org-mode . aspiwack/org-setup-font))
    :bind
    ([remap org-goto] . counsel-org-goto)
    :custom
    ; Changes the symbol representing folding sections (default is `...`
    ; which I rather dislike)
    ; TODO: doesn't work, I don't know why
    (org-ellipsis "⤵" "Changes the symbol to denote folding sections")
    ; Combines with org-appear-mode so that marks reappear when the cursor is on
    ; the text.
    (org-hide-emphasis-markers t "Hides markup on bold, italics,…")
    :config
    (aspiwack/org-setup-babel)
    (aspiwack/org-setup-capture)
    (aspiwack/org-setup-latex))
#+END_SRC

[[https://github.com/sabof/org-bullets][Org-bullets]] decorates the Org bullet headers from ~*~, ~**~, ~***~, … and
replaces them by cute Unicode bullets.

#+begin_src emacs-lisp
    (use-package org-bullets
      :hook (org-mode . org-bullets-mode)
      :after org)
#+end_src

**** Fonts
:PROPERTIES:
:header-args: :noweb-ref org-helpers :tangle no
:END:

#+begin_src emacs-lisp
  (defun aspiwack/org-setup-font ()
    ;; Set faces for heading levels
    (dolist (face '((org-level-1 . 1.2)
                    (org-level-2 . 1.1)
                    (org-level-3 . 1.05)
                    (org-level-4 . 1.0)
                    (org-level-5 . 1.1)
                    (org-level-6 . 1.1)
                    (org-level-7 . 1.1)
                    (org-level-8 . 1.1)))
      (set-face-attribute (car face) nil :font "Linux Biolinum O" :weight 'regular :height (cdr face)))


    ;; Ensure that anything that should be fixed-pitch in Org files appears that way
    (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch))
#+end_src

**** Latex
:PROPERTIES:
:header-args: :noweb-ref org-helpers :tangle no
:END:

Setting up Latex for export from Org to pdf.
- I like to use Xelatex as it has better fonts
- ~minted~ highlights code in exports
- The /memoir/ class serves as a slightly improved book class
#+begin_src emacs-lisp
  (defun aspiwack/org-setup-latex ()
      ; Uses xelatex instead of latex to extract documents into pdf to
    ; allow for better fonts. Passes the `-shell-escape` option to be
    ; able to run minted.
    (setq org-latex-pdf-process
          '("xelatex -shell-escape -interaction nonstopmode %f"
            "xelatex -shell-escape -interaction nonstopmode %f"))

    ; sets up Latex export to highlight the syntax of code blocks
    ; using the minted package
    (add-to-list 'org-latex-packages-alist '("" "minted"))
    (setq org-latex-listings 'minted)

    ; Use imagemagick to create late previews. The reason is that
    ; imagemagick uses the same latex command as the latex export, in
    ; particular it will use xetex, and be compatible with minted.
    (setq org-latex-create-formula-image-program 'imagemagick)

    ; Defines a binding for the memoir class, an improvement over the
    ; default book class. This export class doesn't produce parts. As I
    ; understand it to be able to choose between having parts or chapter
    ; at toplevel, the only way is to have two different classes (as far
    ; as org mode is concerned).  `ox-latex` is required so that the
    ; default value of `org-latex-classes` is loaded
    (require 'ox-latex)
    (add-to-list 'org-latex-classes
           '("memoir"
             "\\documentclass{memoir}"
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
           ))
#+end_src

**** Org structure templates

This used to be the behaviour by default, but in recent Org mode, you
need to add ~org-tempo~ to be able to expand templates such as ~<s~ into
code blocks (and ~<q~ into quotes, etc…).

(As I'm writing this, ~org-tempo~ stopped working for me, I don't know
why. An alternative is ~C-c ~C-,~ (which is awkward in Boon))
#+begin_src emacs-lisp
  ;; In recent Org mode syntax tables, `</>' are declared as delimiters
  ;; (possibly because of timestamp, I don't know), therefore, typing
  ;; `<' is completed by a matching `>' which prevents `org-tempo''s
  ;; expansions. So I deactivate `electric-pair' for this specific
  ;; delimiter.
  (defun aspiwack/no-electric-< ()
    (add-function :before-until electric-pair-inhibit-predicate (lambda (c) (eq c ?<))))

  (use-package org-tempo
    :hook
    (org-mode . aspiwack/no-electric-<)
    :config
    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("hs" . "src haskell"))
    (add-to-list 'org-structure-template-alist '("hask" . "src haskell"))
    )
#+end_src

References:
-  For ~no-electric-<~: [[https://www.reddit.com/r/emacs/comments/j1xdpv/mode_specific_electricpair_behavior/g726o7j/][Reddit]], [[https://emacs.stackexchange.com/questions/55570/yasnippet-avoid-electric-pairs-at-expansion-time/55643#55643][Stackoverflow]]

**** Org-present

To make simple presentation from Org mode document, there is a package
[[https://github.com/rlister/org-present][org-present]]. From an Org file, run ~M-x org-present~ to read the file
as a set of slides.

#+BEGIN_SRC emacs-lisp
  ;; (use-package org-present
  ;;   :commands org-present)
#+END_SRC

**** Htmlize

The [[https://www.emacswiki.org/emacs/Htmlize][htmlize]] package is used to export Org mode document to html with
syntax highlighted code blocks.
#+BEGIN_SRC emacs-lisp
  (use-package htmlize)
#+END_SRC

**** TODO Global default font choice?

***** TODO Roman font family

***** TODO Code font family
This may be set directly with minted

**** TODO Syntax highlighting in exports

***** DONE Pdf

***** TODO Add pygmentize (Package python-pygments in debian/ubuntu) as a requirement

***** TODO Add imagemagick as a requirement
***** DONE Html

**** TODO Split the configuration into sections

**** TODO No spell-checking in code blocks
See
- [[http://emacs.stackexchange.com/questions/450/intelligent-spell-checking-in-org-mode]]
- http://emacs.stackexchange.com/questions/9333/how-does-one-use-flyspell-in-org-buffers-without-flyspell-triggering-on-tangled/9347
- http://endlessparentheses.com/ispell-and-org-mode.html

**** TODO Improve export of time stamps
See
http://endlessparentheses.com/better-time-stamps-in-org-export.html

*** COMMENT Markdown

The popular formatting language has an [[http://jblevins.org/projects/markdown-mode/][Emacs mode]].
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    )
#+END_SRC

*** Melt

Part document description part Ocaml, [[https://forge.ocamlcore.org/projects/melt/][Melt]] is a powerful tool to write
your articles or monographs. The Emacs mode can be found in the
sources of Melt.
#+BEGIN_SRC emacs-lisp
  ;; (setq opam-share (substring (shell-command-to-string "opam config var share 2> /dev/null") 0 -1))
  ;; (add-to-list 'load-path (concat opam-share "/emacs/site-lisp"))

  ;; (require 'melt-mode)

  ;; ; Online spell checking with flyspell
  ;; (add-hook 'melt-mode-hook 'turn-on-flyspell)
#+END_SRC

**** TODO Expand description

***** TODO Speak about latex

***** TODO Links to some of my articles written with Melt

*** COMMENT Latex

#+BEGIN_SRC emacs-lisp
  (use-package tex
    :ensure auctex
    :defer ; the tex mode is, by default, in `automode-alist' auctex
           ; seems to merely override the tex mode. So no configuration
           ; is necessary beyon `:defer'.
    :config
    ; Help input and navigate references and such
    (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
    (setq reftex-plug-into-AUCTeX t))
#+END_SRC

*** COMMENT Typst
[[https://typst.app/][Typst]] is a new authoring format (at time of writing [2023-06-05 lun.],
it's still quite fresh). Aims roughly at the same market as Latex, but
is a better designed language. It's still new, I don't know whether
it's going to catch up. It would be progress, I think.

When Emacs 29 is out, I'll really want to use the Tree-sitter grammar,
because Typst doesn't parse well with regexps.

#+begin_src emacs-lisp
  (use-package typst-mode
    :commands typst-mode
    :hook
    ((typst-mode . eglot-ensure)))
#+end_src

*** Ott
[[https://github.com/ott-lang/ott][Ott]] isn't, strictly speaking, an authoring language. It's a
description language for programming-language-theory type of maths. My
main use of it is in conjunction to Latex for authoring purposes
(everything is macros, and it's much more readable), hence its being here.

#+begin_src emacs-lisp
  (use-package ott-mode)
#+end_src
** Programming languages

Here is some configuration shared by all programming modes which
derive from ~prog-mode~ (in Emacs terminology, ~prog-mode~ is a base
mode, and modes like ~haskell-mode~ derive from ~prog-mode~).
#+BEGIN_SRC emacs-lisp
  (defun aspiwack/fill-in-comments ()
    (setq comment-auto-fill-only-comments t)
    (auto-fill-mode 1))

  (use-package prog-mode
    :hook
    ; Get flyspell to spell-check the comments
    ((prog-mode . flyspell-prog-mode)
     ; (prog-mode . (lambda () (buffer-face-set 'aspiwack/programming)))
     (prog-mode . aspiwack/fill-in-comments))
    )
#+END_SRC

References:
- I found the fill-in-comments method on [[http://stackoverflow.com/questions/4477357/how-to-turn-on-emacs-auto-fill-mode-only-for-code-comments][Stackoverflow]].

*** COMMENT Elastic tabstops

[[https://github.com/jyp/elastic-modes][Elastic-modes]] helps support programming with proportional fonts in two
ways.
- It changes the size of initial spaces on a line to match the
  character on top of it. So that indentation looks the same with
  proportional and monospace fonts.
- It implements [[https://nick-gravgaard.com/elastic-tabstops/][elastic tabstops]] for vertical alignment (which is a
  better way to align vertically even with monospace fonts).

See [[http://jyp.github.io/posts/variable-pitch.html][Jean-Philippe Bernardy's blog post]].

#+begin_src elisp
  (use-package elastic-indent
    :hook
    ((prog-mode . elastic-indent-mode))
    )

  (use-package elastic-table
    :hook
    ((prog-mode . elastic-table-mode))
    )
#+end_src

*** Language server protocol

I used to use [[https://emacs-lsp.github.io/lsp-mode/][lsp-mode]]. But it just tries to take over Emacs too
much. It can hurt productivity as Emacs doesn't always behave
well. These days, Emacs comes with [[https://github.com/joaotavora/eglot][Eglot]] built in, which is more
lightweight.

#+begin_src emacs-lisp
  (use-package eglot
    :config
    (define-prefix-command 'aspiwack/eglot-command-map nil "Eglot")
    (define-key aspiwack/boon-custom-map "l" 'aspiwack/eglot-command-map)
    (define-key aspiwack/eglot-command-map "h" 'eldoc-doc-buffer)
    (define-key aspiwack/eglot-command-map "=" 'eglot-format)
    (define-key aspiwack/eglot-command-map "r" 'eglot-rename)
    (define-key aspiwack/eglot-command-map "a" 'eglot-code-actions)
    )

  ;; Adds breadcrumbs header.
  (use-package breadcrumb
    :config
    (breadcrumb-mode)
    :defer 2)
#+end_src

**** TODO Configure Nickel and Typst servers for Eglot
I may want to check the commit where I wrote those line for some inspiration

*** AI autocompletion

Copilot
#+begin_src emacs-lisp
  (use-package copilot
    ;; Note: copilot.el is provided by Nixpkgs. This way we have an
    ;; appropriate Copilot server available
    :diminish (copilot-mode "✈")
    :config
    (define-key copilot-completion-map (kbd "<tab>") 'copilot-accept-completion)
    (define-key copilot-completion-map (kbd "TAB") 'copilot-accept-completion)
    (define-prefix-command 'aspiwack/copilot-map nil "copilot")
    (define-key aspiwack/boon-custom-map "k" aspiwack/copilot-map)
    (define-key aspiwack/copilot-map "c" 'copilot-complete)
    (define-key aspiwack/copilot-map "a" 'copilot-accept-completion)
    (define-key aspiwack/copilot-map "s" 'copilot-accept-completion-by-word)
    ;; not sure why, but the space command doesn't work. Something takes
    ;; over for some reason
    (define-key aspiwack/copilot-map " " 'copilot-accept-completion-by-line)
    (define-key aspiwack/copilot-map "p" 'copilot-accept-completion-by-line)
    (define-key aspiwack/copilot-map "g" 'copilot-accept-completion-by-paragraph)
    )
#+end_src

*** Elisp

**** Helpful

Richer (and prettier) help for Emacs functions can be provided by [[https://github.com/Wilfred/helpful][helpful]].

#+begin_src emacs-lisp
  (use-package helpful
    :bind
    ([remap describe-function] . helpful-callable)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . helpful-variable))
#+end_src

*** COMMENT Nix

The [[http://nixos.org/nix/][Nix]] language and package manager.
#+BEGIN_SRC emacs-lisp
  (use-package nix-mode)
#+END_SRC

*** COMMENT Ocaml

The [[http://ocaml.org/][Ocaml]] language with [[https://github.com/ocaml/ocaml-lsp][ocaml-lsp-server]]

#+begin_src emacs-lisp
  (use-package tuareg
    :hook
    ((tuareg-mode . eglot-ensure)))
#+end_src

Some support for the [[https://dune.build/][Dune]] build system

#+begin_src emacs-lisp
  (use-package dune)
#+end_src

And for [[https://opam.ocaml.org/][Opam]]

#+begin_src emacs-lisp
  (use-package opam)
#+end_src

**** TODO should I add an indenter (ocp-indent)?
**** COMMENT And old configuration
The [[http://ocaml.org/][Ocaml]] language with [[https://github.com/the-lambda-church/merlin/][Merlin]] and [[https://www.typerex.org/ocp-indent.html][~ocp-indent~]]. (this is quite a bit out of date)
#+BEGIN_SRC emacs-lisp
  ;; ocaml-tuareg mode
  ;; Add opam emacs directory to the load-path
  (setq opam-share (substring (shell-command-to-string "opam config var share 2> /dev/null") 0 -1))
  (add-to-list 'load-path (concat opam-share "/emacs/site-lisp"))

  (load (concat opam-share "/emacs/site-lisp/tuareg-site-file"))

  ;; installed via package manager
  ;; ocp-indent
  ;; (require 'ocp-indent)

  ;; merlin
  ;; Load merlin-mode
  ;;(require 'merlin)
  ;; Start merlin on ocaml files
  (add-hook 'tuareg-mode-hook 'merlin-mode t)
  (add-hook 'caml-mode-hook 'merlin-mode t)
  ;; Enable auto-complete
  ; Make company aware of merlin
  (aspiwack/add-company-backend 'merlin-company-backend)
  ;; Use opam switch to lookup ocamlmerlin binary
  (setq merlin-command 'opam)
#+END_SRC

*** COMMENT Coq

The [[https://coq.inria.fr/][Coq]] proof assistant and programming language, with [[https://github.com/ProofGeneral/PG][Proof general]].
#+BEGIN_SRC emacs-lisp
  ;; ProofGeneral generic mode
  ;; (use-package proof-general)
#+END_SRC

**** TODO Describe configuration

**** TODO Link to Quail configuration

**** TODO Steal ideas from this config?
http://endlessparentheses.com/proof-general-configuration-for-the-coq-software-foundations-tutorial.html

*** COMMENT Haskell

The [[https:y//www.haskell.org/][Haskell]] programming language.
#+BEGIN_SRC emacs-lisp
  ;;;; hindent: indentation mode for Haskell
  (use-package hindent
    :commands hindent
    :init
    ; HACK: hident installed with nix. Can I get rid of it?
    (setq hindent-process-path "/home/aspiwack/.local/bin/hindent")
    :config
    (setq hindent-style "johan-tibell")
    :diminish hindent-mode
   )

  ;;; haskell-mode proper
  (use-package haskell-mode
    :config
    (defun haskell-hook ()
      ; set maximum column length
      (set-fill-column 80)
      ; show a marker at maximum column length
      (display-fill-column-indicator-mode)
      ; set indentation mode to hindent (TODO: better: use Ormolu to format)
      (hindent-mode)
      )
    (add-hook 'haskell-mode-hook 'haskell-hook)
    :hook
    ((haskell-mode . eglot-ensure))
    :defer)
#+END_SRC

This is a more generic purpose package (split off Dante) to repair
errors using flycheck. It's here because I currently only use it for
Haskell.
#+BEGIN_SRC emacs-lisp
  (use-package attrap
    ;; :load-path "~/projects/contributions/attrap/master"
    :bind (("C-x /" . attrap-attrap)))
#+END_SRC

**** TODO In progress

**** TODO Comments and sections

**** TODO Programming environment

***** TODO Load interactive session on startup

***** TODO Create tags on save

***** TODO Rebind M-. to use both ghci and tags?

*** Rust

#+begin_src emacs-lisp
  (use-package rust-mode)
#+end_src

*** Misc

Miscellaneous programming language (or adjacent) modes

#+BEGIN_SRC emacs-lisp
  (use-package terraform-mode)
#+END_SRC

** Configuration formats
*** Yaml
#+begin_src emacs-lisp
  (use-package yaml-mode)
#+end_src
*** Nickel
#+begin_src emacs-lisp
  (use-package nickel-mode
    :hook
    ((nickel-mode . eglot-ensure)))

#+end_src

** Other languages

*** Just
[[https://just.systems/][Just]] is a tool to provide commands to projects. It's configured with a
~justfile~, with a syntax reminiscent of ~make~. Contrary to ~make~, every
command is called every time, and commends can take arguments. Just
can also list commands with a help line natively, something which is
possible in ~make~, but with hacks. On the other hand, contrary to ~make~,
it's not installed on every machine. But I'm still content to
experiment with it a little, as this is how I've been using ~make~ for
the most part. And since I tend to use a ~shell.nix~ it's not very
problematic.

[[https://github.com/leon-barrett/just-mode.el][Just-mode]] is a highlighting mode for ~justfile~
#+begin_src emacs-lisp
  (use-package just-mode)
#+end_src

[[https://github.com/psibi/justl.el][Justl]] helps with calling Just commands from within Emacs. The entry point is ~M-x justl~.
#+begin_src emacs-lisp
  (use-package justl
    :bind
    (:map aspiwack/boon-custom-map
          ("j" . justl)))
#+end_src
* Multi-modes

I use [[https://polymode.github.io/][Polymode]] to mix several modes in the same buffer. Most typically
to have ~haskell-mode~ in Latex/Haskell Literate Haskell files.

#+begin_src emacs-lisp
  (use-package polymode)
#+end_src

** Latex/Haskell

I don't think that there is a reliable way to start this mode
automatically (/e.g./ the ~.lhs~ instance can be a Latex file or another
form of Literate Haskell file). Therefore it needs to be started
manually per file (either by calling the ~poly-latex-lhs-mode~ command,
or by adding the mode in file- or dir-local variables).

I've had success adding the following to my dir-local variables (the
best way to add a dir-local variable is to call ~M-x
add-dir-local-variable~ when in the appropriate ~.dir-locals.el~. For the
variable, choose ~eval~, in this particular case)

#+begin_src emacs-lisp :tangle no
((nil . ((eval . (add-hook 'hack-local-variables-hook
                           (lambda () (when (derived-mode-p 'latex-mode)
                                        (poly-latex-lhs-mode))))))))
#+end_src

#+begin_src emacs-lisp
  (define-innermode aspiwack/poly-latex-haskell-innermode
    :mode 'haskell-mode
    :head-matcher "^[ \t]*\\\\begin{\\(code\\|spec\\)}"
    :tail-matcher "^[ \t]*\\\\end{\\(code\\|spec\\)}"
    :head-mode 'host
    :tail-mode 'host)

  (define-polymode poly-latex-lhs-mode poly-latex-root-polymode
    :innermodes '(aspiwack/poly-latex-haskell-innermode))
#+end_src

* Operating system


This section is about all the use of Emacs as a tool to manage , or,
more generally, interact with, the operating system. Stuff like file
management, shells, etc…

** Dired

Dired is Emacs's built-in file manager.

#+begin_src emacs-lisp
  (use-package dired
    ;; dired is built-in
    :hook
    (dired-mode . aspiwack/dired-hide-detail-at-at-startup)
    :custom
    (dired-listing-switches "-alh --group-directories-first" "Better ls options")
    (dired-hide-details-hide-symlink-targets nil "Don't hide symlink targets in hide-details")
    (dired-dwim-target t "Use other dired pane to guess target for copy directory")
    :config
    (define-key dired-mode-map "]" 'dired-do-async-shell-command)
    (define-key dired-mode-map "[" 'aspiwack/dired-do-async-xdg-open)
  )

  (defun aspiwack/dired-hide-detail-at-at-startup ()
    (dired-hide-details-mode 1))

  (defun aspiwack/dired-do-async-xdg-open (&optional arg file-list)
    "Use `dired-do-async-shell-command' to open marked files with
    `xdg-open'"
    (interactive
      (let ((files (dired-get-marked-files t current-prefix-arg nil nil t)))
       (list
        current-prefix-arg
        files)))
    (dired-do-async-shell-command "xdg-open" arg file-list))
#+end_src

Add icons

#+begin_src emacs-lisp
  (use-package nerd-icons-dired
    :hook
    (dired-mode . nerd-icons-dired-mode))
#+end_src

** Running command

This hides the output buffer of ~async-shell-command~. It usually pops
up as soon as you send a command, but I don't typically want to read
the buffer. So, instead, let it be created in the background.

This solution was found at https://stackoverflow.com/a/47587185

#+begin_src emacs-lisp
  (add-to-list 'display-buffer-alist
    (cons "\\*Async Shell Command\\*.*" (cons #'display-buffer-no-window nil)))
#+end_src

** COMMENT Emacs application framework

[[https://github.com/manateelazycat/emacs-application-framework][Emacs application framework]] lets one open graphical applications
within Emacs.

Some dependencies
#+begin_src emacs-lisp
  (use-package ctable
    :pin melpa-stable)
  (use-package epc
    :pin melpa-stable)
#+end_src

#+begin_src emacs-lisp
  (use-package eaf
    :quelpa
     (eaf :fetcher github
           :repo  "manateelazycat/emacs-application-framework"
           :files ("*")))
#+end_src

** Terminals

*** EAT
[[https://codeberg.org/akib/emacs-eat][EAT]] is an emulated terminal in Elisp. But it works really well, at
least I've had a good experience with it. Not as native as Vterm, but
this makes the integration smoother. More normal a terminal than
Eshell. It's become my default choice of terminal inside Emacs.

#+begin_src emacs-lisp
  (use-package eat)
#+end_src
* Applications

** Weechat

[[https://github.com/the-kenny/weechat.el][Emacs client]] to connect to a [[http://weechat.org/][Weechat]] server.
#+BEGIN_SRC emacs-lisp
  ;; (use-package weechat
  ;;   ; does not load the mode until the `weechat-connect` command has
  ;;   ; been used.
  ;;   :commands weechat-connect
  ;;   :init
  ;;   (custom-set-variables
  ;;      '(weechat-host-default "mowgli.spiwack.net")
  ;;      '(weechat-port-default 8001)
  ;;      '(weechat-modules '(
  ;;                    ; Make link clickable (default)
  ;;                    weechat-button
  ;;                    ; Nickname and command completion (default)
  ;;                    weechat-complete
  ;;                    ; Spell-checking with flyspell
  ;;                    weechat-spelling
  ;;                    ; Enables desktop notifications
  ;;                    weechat-notifications
  ;;                    ; Store passwords with secrets.el
  ;;                    weechat-secrets
  ;;                    ; Use `C-c C-spc` to circle between "hot" buffers
  ;;                    weechat-tracking
  ;;                    ; Previews Latex code (using Org mode's Latex preview)
  ;;                    ; Deactivated because it doesn't work that well
  ;;                    ;; 'weechat-latex
  ;;                    ; Preview images
  ;;                    weechat-image))
  ;;      ; Retrieves a stored password automatically when a password is
  ;;      ; required. Weechat also reconnects automatically to the server
  ;;      ; if it can get a password this way.
  ;;      '(weechat-password-callback 'weechat-secrets-get-password)
  ;;      '(weechat-spelling-dictionaries '())
  ;;      )

  ;;   :config
  ;;   ; Activates the visual line mode which, in particular, wraps line
  ;;   ; based on word boundaries (see `word-wrap')
  ;;   (add-hook 'weechat-mode-hook 'visual-line-mode)
  ;;   ; Deactivated because Latex preview doesn't work that well
  ;;   ;; (add-hook 'weechat-mode-hook 'weechat-latex-auto-mode)
  ;;   )
#+END_SRC

About the ~secrets.el~ features. See the [[https://www.gnu.org/software/emacs/manual/html_node/auth/Secret-Service-API.html][relevant section of the Emacs
documentation]].

Instructions:
- ~M-x weechat-secrets-create~, enter and confirm the password for the
  appropriate host/port pair. The first time, you will be prompted to
  create a keyring this requires another password, which you will have
  to type when you log in your computer.

At the time writing this [2016-02-12 ven.], there is [[https://github.com/the-kenny/weechat.el/pull/47][a bug in the
~secrets.el~ feature of ~weechat.el~.]] To work around it, I do ~M-x
trace-function~ on ~secrets-create-item~ before doing
~weechat-secrets-create~, then evaluate ~secrets-create-item~ (with
~M-:~) with the same inputs except the number after ~:port~ is
replaced by the corresponding string.

*** TODO Add the "francais" dictionary as a requirement
~sudo apt-get install aspell-fr~

** Vagrant

[[https://www.vagrantup.com/][Vagrant]] is a tool to create virtual machines. Since it uses a
roundabout way to connect to ssh, Emacs requires a [[https://github.com/dougm/vagrant-tramp][package]] to be able
to connect via [[http://www.gnu.org/software/tramp/][TRAMP]]. Connect to a vagrant machine with ~C-x C-f
/vagrant:~.

#+BEGIN_SRC emacs-lisp
  ;; (use-package vagrant-tramp)
#+END_SRC

* Misc

** Math input method

This section sets up an input method — based on Latex mathematical
symbols — for Unicode mathematical symbols. Input methods can be
toggled on and off with ~C-\~.

*** Custom bindings

Here is a list of bindings I defined.

#+BEGIN_SRC emacs-lisp
(defun aspiwack-quail-bindings () '(
#+END_SRC

**** Shortcuts for Greek letters
#+BEGIN_SRC emacs-lisp
          ("\\ga" "α")
          ("\\gb" "β")
          ("\\gg" "γ")
          ("\\gG" "Γ")
          ("\\GG" "Γ")
          ("\\ge" "ε")
          ("\\gh" "η")
          ("\\gl" "λ")
          ("\\GL" "Λ")
          ("\\gL" "Λ")
          ("\\gy" "υ")
#+END_SRC

**** Arrows
#+BEGIN_SRC emacs-lisp
          ("\\->" "→")
          ("\\-->" "⟶")
          ("\\<-" "←")
          ("\\<--" "⟵")
          ("\\<->" "↔")
          ("\\<-->" "⟷")
          ("\\<|" "↓")
          ("\\|>" "↑")
          ("\\<|>" "↕")
          ("\\=>" "⇒")
          ("\\==>" "⟹")
          ("\\<=" "⇐")
          ("\\<==" "⟸")
          ("\\<=>" "⇔")
          ("\\<==>" "⟺")
          ("\\-o" "⊸")
          ("\\||>" "⇑")
          ("\\<||" "⇓")
          ("\\<||>" "⇕")
#+END_SRC

**** Overriding comparison symbols
Replace the default variants with the variants which have a slanted
equality sign.
#+BEGIN_SRC emacs-lisp
          ("\\leq" "⩽")
          ("\\geq" "⩾")
#+END_SRC

**** Mathematical double-struck characters
#+BEGIN_SRC emacs-lisp
          ("\\bb0" "𝟘")
          ("\\bb1" "𝟙")
          ("\\bbB" "𝔹")
          ("\\bbG" "𝔾")
          ("\\bbH" "ℍ")
          ("\\bbi" "𝕚")
          ("\\bbI" "𝕀")
          ("\\bbK" "𝕂")
          ("\\bbN" "ℕ")
          ("\\bbS" "𝕊")
          ("\\bbZ" "ℤ")
#+END_SRC

**** Bold characters
#+BEGIN_SRC emacs-lisp
          ("\\bC" "𝗖")
          ("\\bH"  "𝗛")
#+END_SRC

**** Delimiters
#+BEGIN_SRC emacs-lisp
          ("\\la" "⟨")
          ("\\ra" "⟩")
#+END_SRC

**** Logical symbols
#+BEGIN_SRC emacs-lisp
          ("\\fa" "∀")
          ("\\ex" "∃")
          ("\\==" "≡")
          ("\\eqdef" "≜")
          ("\\|-" "⊢")
          ("\\cand" "⋏")
          ("\\cor" "⋎")
          ("\\contains" "∋")
#+END_SRC

**** Mathematical script characters
#+BEGIN_SRC emacs-lisp
          ("\\cC" "𝒞")
          ("\\cD" "𝒟")
          ("\\cP" "𝒫")
#+END_SRC

**** Mathematical bold script characters
#+BEGIN_SRC emacs-lisp
          ("\\bcA" "𝓐")
          ("\\bcB" "𝓑")
          ("\\bcC" "𝓒")
          ("\\bcD" "𝓓")
          ("\\bcE" "𝓔")
          ("\\bcF" "𝓕")
          ("\\bcG" "𝓖")
          ("\\bcP" "𝓟")
#+END_SRC

**** Misc
#+BEGIN_SRC emacs-lisp
          ("\\comp" "∘")
          ))
#+END_SRC

*** Loading mathematical symbols

First let us load the quail package, which defines input methods for
Emacs.
#+BEGIN_SRC emacs-lisp
   (use-package quail)
#+END_SRC

Then, the [[https://github.com/vspinu/math-symbol-lists][math-symbol-lists]] package is used as a source to define an
input method called /math/.
#+BEGIN_SRC emacs-lisp
  (use-package math-symbol-lists
    ;:after quail

    :init
    ; adds a list of bindings of the form `(KEY TRANSLATION)` to an
    ; input method
    (defun defrules-from-pairs (pairs method)
      (mapc (lambda (pair)
              (quail-defrule (car pair) (cadr pair) method))
            pairs))
    ; add a list of bindings of the form `(SOMETHING KEY TRANSLATION)`
    ; to an input method. Skips a binding if it doesn't contain a
    ; `TRANSLATION`.
    (defun defrules-from-triples (triples method)
      (mapc (lambda (triple)
              (if (cddr triple)
                  (quail-defrule (cadr triple) (caddr triple) method)))
            triples))

    :config
    ; Creates an input method with the symbols from `math-symbol-list`.
    (quail-define-package "math" "UTF-8" "Ω" t)
    (defrules-from-triples math-symbol-list-basic "math")
    (defrules-from-triples math-symbol-list-extended "math")
    ; extends the input method with custom bindings.
    (defrules-from-pairs (aspiwack-quail-bindings) "math")
    :defer t
    )
#+END_SRC


** COMMENT Automatically upgrade packages

Commented as I don't use this anymore.

With [[https://github.com/rranelli/auto-package-update.el][~auto-package-update.el~]], packages installed with ~package.el~
are automatically upgraded regularly.
#+BEGIN_SRC emacs-lisp
  (use-package auto-package-update
    :init
    ; update every 30 days (bonus: 30 is coprime with 7, hence update
    ; happens, in turn, on each of the 7 week days)
    (setq auto-package-update-interval 30)
    ; Delete older version of packages
    (setq auto-package-update-delete-old-versions t)
    :config
    ; If there are upgrades pending, upgrade the corresponding package
    ; when loaded.
    (auto-package-update-maybe)
    ; Do not load at startup (it would needlessly slow down startup
    ; while very few startups will actually trigger an update). Instead,
    ; load after sufficient idle time as to indicate that I'm probably
    ; not typing in that buffer (that way updates will most likely not
    ; affect my typing).
    :defer 30)

#+END_SRC

** Push desktop notifications

See the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Desktop-Notifications.html][documentation]].
#+BEGIN_SRC emacs-lisp
  (use-package notifications)
#+END_SRC

** Sending lines to opposite buffer

#+BEGIN_SRC emacs-lisp
  (defun send-to-eshell ()
    "Paste content of the kill ring to the eshell buffer"
    (interactive)
    (append-to-buffer "*eshell*"
                      (line-beginning-position)
                      (line-end-position))
    (set-buffer "*eshell*")
    (eshell-send-input))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c C-s") 'send-to-eshell)
#+END_SRC

* Things that must be late

** COMMENT Direnv

[[https://github.com/purcell/envrc][Envrc]] is a buffer-local mode for [[https://direnv.net/][direnv]]. When working on several
project in the same Emacs session, the direnv environment of each
buffer is picked up.

#+begin_src emacs-lisp
  (use-package envrc
    :config
    (envrc-global-mode))
#+end_src
